<div dir="rtl" align="right">


# 📚 هرم دودویی | Binary Heap

هرم دودویی برای ساخت صف اولویت و همچنین مرتب‌سازی کاربرد دارد.

هرم‌های دودویی به دو دسته تقسیم می‌شوند:

### 🧩 هرم دودویی کمینه | Binary Minheap
یک درخت دودویی کامل است که در هر نود آن یک کلید (عدد) وجود دارد و کلید هر نود از کلید فرزندان آن نود، کوچک‌تر یا مساوی است.

### 🧩 هرم دودویی بیشینه | Binary Maxheap
یک درخت دودویی کامل است که در هر نود آن یک کلید (عدد) وجود دارد و کلید هر نود از کلید فرزندان آن نود، بزرگ‌تر یا مساوی است.

<div align="center">
  
![Alt text](./images/1.png)

</div>


### ⚠️ یادآوری

 درخت دودویی کامل، همۀ سطوح ماقبل آخرش پر می‌باشد و نودها در سطح آخر آن، از چپ قرار می‌گیرند. درخت دودویی کامل شامل n گره را می‌توان با آرایۀ $A[1, ..., n]$ نشان داد که $A\left[1, ..., \Bigl\lfloor\frac{n}{2}\Bigr\rfloor\right]$ گره‌های داخلی و $A\left[\Bigl\lfloor\frac{n}{2}\Bigr\rfloor + 1, ..., n\right]$ گره‌های خارجی (برگ) هستند.

در درخت دودویی کامل، روابط پدر و فرزندی به شکل زیر است:

<div align="center">
  
$`Parent(i) = \Bigl\lfloor\frac{i}{2}\Bigr\rfloor \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;(i \geqslant 1)`$

$`Left(i) = 2i \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;(2i \leqslant n)`$

$`Right(i) = 2i + 1 \;\;\;\;\;\;\;\;\;\;\;\;\;(2i + 1 \leqslant n)`$

</div>

تشخیص اینکه آرایۀ $A[1, ..., n]$، یک Minheap یا Maxheap است، از مرتبۀ $\boldsymbol{\mathcal{O}(n)}$ است. زیرا باید ...

## 💡 نکات مهم
با توجه به ساختار هرم کمینه و هرم بیشینه، به راحتی می‌توان نکات زیر را استنباط کرد:

### 📌 هرم بیشینه
در هرم بیشینه، بزرگ‌ترین کلید در ریشه است و کوچک‌ترین کلید در یکی از برگ‌هاست. پس در Maxheap یافتن ماکزیمم از مرتبۀ $\boldsymbol{\theta(1)}$، و یافتن مینیمم از مرتبۀ $\boldsymbol{\theta(n)}$ می‌باشد، زیرا برای یافتن ماکزیمم باید تمام $\Bigl\lceil\frac{n}{2}\Bigr\rceil$ برگ، بررسی شوند.

### 📌 هرم کمینه
در هرم کمینه، کوچک‌ترین کلید در ریشه است و بزرگ‌ترین کلید در یکی از برگ‌هاست. پس در Minheap یافتن مینیمم از مرتبۀ $\boldsymbol{\theta(1)}$، و یافتن ماکزیمم از مرتبۀ $\boldsymbol{\theta(n)}$ می‌باشد، زیرا برای یافتن مینمم باید تمام $\Bigl\lceil\frac{n}{2}\Bigr\rceil$ برگ، بررسی شوند.

### 📌 ارتفاع هرم
از آنجایی که هرم درخت کامل است، پس تعداد سطوح هرم با n گره، برابر $\lfloor\log n\rfloor + 1$ است. در نتیجه ارتفاع هرم برابر $\lfloor\log n\rfloor$ است.






## 📥 درج در هرم بیشینه

می‌خواهیم کلید x را در هرم بیشینه درج کنیم. از آنجایی که هرم درخت دودویی کامل است، کلید x را در انتهای هرم یعنی در اولین مکان خالی، قرار می‌دهیم؛ سپس x را با اجدادش مقایسه می‌کنیم و تا زمانی که x از پدرش بزرگ‌تر است، جای x را با پدرش عوض می‌کنیم.

**مثال)** ابتدا کلید 30 و سپس کلید 40 را در هرم بیشینه درج کنید.

<div align="center">
  
![Alt text](./images/2.png)

</div>

طول آرایه (Length(A)) برابر 8 است که ثابت است. تعداد عناصر موجود در هرم (Heapsize(A)) برابر 6 است. با هر عمل درج، یک واحد به Heapsize اضافه می‌شود.

**مرحله اول درج کلید 30**

این کلید را در A[7] قرار می‌دهیم (Heapsize برابر 7 می‌شود). سپس 30 را با A[3] = 15 مقایسه می‌کنیم و چون $15 < 30$ است، باید 30 با 15 جابه‌جا شود. حالا 30 را با A[1] = 35 مقایسه می‌کنیم و چون $30 < 35$ است، نیازی به جابه‌جایی نیست.

<div align="center">
  
![Alt text](./images/3.png)

</div>

**مرحله دوم درج کلید 40**

این کلید را در A[8] قرار می‌دهیم (Heapsize برابر 8 می‌شود). ابتدا 40 را با A[4] = 20 مقایسه می‌کنیم و چون $20 < 40$ است، باید 40 با 20 جابه‌جا شود. سپس 40 را با A[2] = 25 مقایسه می‌کنیم و چون $25 < 40$ است، باید 40 با 25 جابه‌جا شود. حالا 40 را با A[1] = 35 مقایسه می‌کنیم و چون $35 < 40$ است، 40 با 35 جابه‌جا می‌شود.

<div align="center">
  
![Alt text](./images/4.png)

</div>


برای درک بهتر مثال، شکل درخت را در هر مرحله می‌کشیم:

<div align="center">
  
![Alt text](./images/5.png)

</div>

پس جمعا با 4 جابه‌جایی، کلیدهای 30 و 40 در هرم بیشینه درج شدند.

زمان اجرای درج یک کلید، به ارتفاع درخت وابسته است و چون ارتفاع درخت کامل شامل n گره، برابر $\lfloor\log n\rfloor$ است، پس عمل درج یک کلید در هرم، از مرتبۀ $\boldsymbol{\mathcal{O}(\log n)}$ می‌باشد.